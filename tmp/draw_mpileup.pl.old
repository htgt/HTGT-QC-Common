#!/usr/bin/env perl
use strict;
use warnings FATAL => 'all';

use Smart::Comments;
use feature qw( say );

open ( my $fh, '<', $ARGV[0] ) or die 'Can not open file';

# 0 = chromosome
# 1 = position ( 1 based )
# 2 = ref base
# 3 = read depth
# 4 = read bases
# 5 = base qualities

# read bases
# . = match to reference on forward strand
# , = match to reference on reverse strand
# AGCTN = mismatch on forward strand
# agctn = mismatch on reverse strand
# ^ = start of read
# $ = end of read
# +4ACGT = insertion of sequence, 4 bases ACGT
# -4CACC = deletion of sequence, 4 bases CACC

# TODO send in start / end genomic coordiantes we want to look at
#      need this to trim the sequences to the area of interest

my ( %seqs, $first_read, $second_read, %insertions );
my %active_reads = (
    forward => 0,
    reverse => 0,
);

my $pos = 0;
while ( <$fh> ) {
    chomp;
    my ( $chr, $start, $ref, $depth, $reads, $quality ) = split(/\t/);
    if ( $pos == 0 ) {
        calculate_read_positions( $reads );
    }

    my $read_array = split_reads( $reads, $depth );

    # always add current reference base to reference sequence
    $seqs{ref} .= $ref;

    build_sequences( $read_array, $ref, $depth );
    $pos++;
}

sub calculate_read_positions {
    my $read = shift;

    $read =~ /^\^.(.)/;
    die ( "Can not calculate read positions: $read" ) unless $1;

    if ( $1 =~ /,/ || $1 =~ /[actgn]/ ) {
        $first_read  = 'reverse';
        $second_read = 'forward';
    }
    elsif ( $1 =~ /\./ || $1 =~ /[ACTGN]/ ) {
        $first_read  = 'forward';
        $second_read = 'reverse';
    }
    else {
        die( "Can not calculate read positions: $read" );
    }

    return;
}

sub build_sequences {
    my ( $read_array, $ref, $depth ) = @_;

    if ( $depth == 1 ) {
        build_single_sequence( $read_array->[0], $ref );
    }
    elsif ( $depth == 2 ) {
        build_sequence( $first_read, $read_array->[0], $ref );
        build_sequence( $second_read, $read_array->[1], $ref );
    }
    elsif ( $depth == 0 ) {
        $seqs{forward} .= ' ';
        $seqs{reverse} .= ' ';
    }
}

sub build_sequence {
    my ( $name, $read, $ref ) = @_;
    $seqs{$name} .= calculate_insert( $read, $ref );
}

sub build_single_sequence {
    my ( $read, $ref ) = @_;

    if ( $active_reads{forward} ) {
        $seqs{forward} .= calculate_insert( $read, $ref );
        $seqs{reverse} .= ' ';
    }
    elsif ( $active_reads{reverse} ) {
        $seqs{reverse} .= calculate_insert( $read, $ref );
        $seqs{forward} .= ' ';
    }
    else {
        # in the case where 2 reads do not overlap
        $seqs{$first_read}  .= calculate_insert( $read, $ref );
        $seqs{$second_read} .= ' ';
    }
}

sub calculate_insert {
    my ( $read, $ref ) = @_;

    if ( $read =~ /[.,]/ ) {
        return $ref;
    } 
    elsif ( $read =~ /^([A-za-z])$/ ) {
        return lc($1);
    }
    elsif ( $read eq '*' ) {
        return '-';
    }
    else {
        die( "Not sure what to do with $read" );
    }
}

sub split_reads {
    my ( $reads_string, $read_depth ) = @_;

    return if $read_depth == 0;

    # deal with indels first, strip them out and store the insertions
    while ( $reads_string =~ /[-+](?<count>[0-9]+)/ ) {
        my $count = $+{count};
        $reads_string =~ s/(?<expr>[-+][0-9]+(?<seq>[A-za-z]{$count}))//;
        my $expr = $+{expr};
        my $seq = $+{seq};
        if ( $expr =~ /^\+/ ) {
            push @{ $insertions{$pos} }, $seq;
        }
    }

    # now deal with start / stops, need to strip them out and set active / inactive flags
    if ( $reads_string =~ /\^/ ) {
        # strip ^] from read string
        $reads_string =~ s/\^.//;
        if ( $read_depth == 1 ) {
            if ( $pos == 0 ) {
                $active_reads{$first_read} = 1; 
            }
            else {
                $active_reads{$second_read} = 1; 
            }
        }
        else {
            $active_reads{$second_read} = 1; 
            # in the unlikely case both reads start in same place 
            if ( $reads_string =~ s/\^.// ) {
                $active_reads{$first_read} = 1; 
            }
        }
    }
    
    if ( $reads_string =~ /\$/ ) {
        if ( $read_depth == 2 ) {
            if ( $reads_string =~ /\$$/ ) {
                $active_reads{$second_read} = 0;
            }
            else {
                $active_reads{$first_read} = 0;
            }
        }
        else {
            # de-activate reads if depth is 1
            $active_reads{forward} = 0;
            $active_reads{reverse} = 0;
        }
        $reads_string =~ s/\$//g;
    }

    # if the read depth is one return it
    if ( $read_depth == 1 ) {
        die ( "String should only have 1 char: $reads_string"  ) if length($reads_string) != 1;
        return [ $reads_string ];
    }
    # otherwise split in 2 and return that ( should only be left with 2 chars in string )
    elsif ( $read_depth == 2 ) {
        die ( "String should only have 2 chars: $reads_string" )  if length($reads_string) != 2;
        return [ split('', $reads_string ) ];
    }
    else {
        die( "Read depth can only be 0, 1 or 2: $read_depth" );
    }

    return;
}

sub parse_insertions {
    my @insert_positions = sort { $b <=> $a } keys %insertions;

    for my $pos ( @insert_positions ) {
        my $inserts = $insertions{$pos};
        if ( scalar( @{ $inserts } ) == 1 ) {
            my $seq = $inserts->[0];
            my $length = length( $seq );
            if ( $seq =~ /^[actgn]+$/ ) {
                add_insertion( 'reverse', $pos, $length, $seq );
                add_insertion( 'forward', $pos, $length );
                add_insertion( 'ref', $pos, $length );
            }
            elsif ( $seq =~ /^[ACTNG]+$/ ) {
                add_insertion( 'forward', $pos, $length, $seq );
                add_insertion( 'reverse', $pos, $length );
                add_insertion( 'ref', $pos, $length );
            }
            else {
                die("Unexpected insert sequences $seq");
            }
        }
        elsif ( scalar( @{ $inserts } ) == 2 ) {
            my $insert_0_length = length( $inserts->[0] );
            my $insert_1_length = length( $inserts->[1] );
            my ( $insert_1_type, $insert_0_type );
            if ( $inserts->[0] =~ /^[actgn]+$/ ) {
                $insert_0_type = 'reverse';
                $insert_1_type = 'forward';
            }
            elsif ( $inserts->[0] =~ /^[ACTGN]+$/ ) {
                $insert_0_type = 'forward';
                $insert_1_type = 'reverse';
            }
            else {
                die("Unexpected insert sequences: " . $inserts->[0] );
            }

            if ( $insert_1_length == $insert_0_length ) {
                add_insertion( $insert_0_type, $pos, $insert_1_length, $inserts->[0] );
                add_insertion( $insert_1_type, $pos, $insert_1_length, $inserts->[1] );
                add_insertion( 'ref', $pos, $insert_1_length );
            }
            elsif ( $insert_0_length > $insert_1_length ) {
                add_insertion( $insert_0_type, $pos, $insert_0_length, $inserts->[0] );
                my $pad_seq = '-' x ( $insert_0_length - $insert_1_length );
                add_insertion( $insert_1_type, $pos, $insert_0_length, $inserts->[1] . $pad_seq );
                add_insertion( 'ref', $pos, $insert_1_length );
            }
            elsif ( $insert_1_length > $insert_0_length ) {
                add_insertion( $insert_1_type, $pos, $insert_1_length, $inserts->[1] );
                my $pad_seq = '-' x ( $insert_1_length - $insert_0_length );
                add_insertion( $insert_0_type, $pos, $insert_1_length, $inserts->[0] . $pad_seq );
                add_insertion( 'ref', $pos, $insert_1_length );
            }
            else {
                die( "Not sure how to deal with insert sequences" );
            }
        }
        else {
            die( "Too many insert sequencs at position $pos: " . scalar( @{ $inserts } ) );
        }

    }
}

sub add_insertion {
    my ( $seq_name, $position, $length, $insert_seq ) = @_;
    $insert_seq //= '-' x $length;

    substr( $seqs{$seq_name}, $position, 0, uc( $insert_seq ) );
}

### %insertions
parse_insertions();
my $length = length( $seqs{ref} );
my $start = 0; 
while ( ( $start + 230 ) < $length  ) {
    say 'G: ' . substr( $seqs{ref}, $start, 230 );
    say 'F: ' . substr( $seqs{forward}, $start, 230 );
    say 'R: ' . substr( $seqs{reverse}, $start, 230 );
    say '---';
    $start += 230;
}
